# -*- coding: utf-8 -*-
"""polish-sentences-classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SdkQwDrh1ZcTLOCp4jzNcAXt5ThaYHlV

Mateusz Hawrot |

### The assumptions based on the task description:
- Problem based on the multi-label classification where we need to distinguish whether a certain sentence is neutral, cyberbullying or hate speech
- Dataset is given with training and testing examples - initially, I split data in 80/20 proportion for testing in training. In later development, I used the given training set (approx. 10k) for the training and testing test (approx. 1k) for validation 
- I performed data-cleaning for the given dataset. However, finally, I am not certainly happy with the results. I think too much data were extracted in the preprocessing stage. I could not explore more due to the deadline for submission. Polish stopwords extracted using data from [bieli/stopwords git repo](https://github.com/bieli/stopwords)
- I have experimented with the architecture of the NN. Changed some activation functions, added dropout to deal with the overfitting. 
- For the Embedding, I have used Glove for polish sentences. The model was taken from this repo: [polish-nlp-resources](https://github.com/sdadas/polish-nlp-resources)
- In the further step I could implement a Transformer for the network such as BERT and try to increase the accuracy of the model. 


---



I think it is worth mentioning that during the preprocessing I have noticed that the distribution of the data between the labels overweights towards neutral sentences (around 82%). I think, for the further preprocessing steps it would be rational to balance the data. I did not do it for the notebook, however, I think it is a good idea for the further data argumentation process. 


---



The final distribution for the loss and accuracy of the model looks like this:


![Unknown.png](data:image/png;base64,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)

### Possible solution for model deployment:

For the model demployment I could use a service called SageMaker provided by AWS. The following steps would be required:
- Create a Notebook in SageMaker with a new instance of S3 bucket (which will serve all the files required for the model)
- Upload a jupyter notebook to the instance created in SageMaker - we need to add additional imports to the notebook:
  - import sagemaker, boto3
  - assign the prefix and initialise the session using boto3
  - assign the region and role with sagemaker
  - upload files into S3 instance using configured before boto3
  - train the model and validate the input with sagemaker
  - deploy the model with sagemaker

Start of the notebook
"""

import pandas as pd
import re
import nltk
import os
from sklearn.model_selection import train_test_split
import numpy as np

from keras.layers import Lambda, GlobalAveragePooling1D, Dense, Embedding
from keras.preprocessing.text import text_to_word_sequence
import tensorflow as tf
from tensorflow.keras.layers import Conv1D, Bidirectional, LSTM, Dense, Input, Dropout, BatchNormalization, LeakyReLU
from tensorflow.keras.layers import SpatialDropout1D
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.optimizers import Adam, SGD, Adagrad
from tensorflow.keras.callbacks import ReduceLROnPlateau

import matplotlib.pyplot as plt
from sklearn.metrics import fbeta_score

from google.colab import drive
drive.mount('/content/gdrive')

!unzip task_6-2.zip

!unzip task6_test.zip

!unzip /content/gdrive/MyDrive/Engineering/nlp-assignment/glove.zip

def load_training():
  # Load training data (sentences)
  train_data = df = pd.read_csv('training_set_clean_only_text.txt', delimiter = "\t", header=None)
  train_data.columns = ["text"]

  # Load lables
  train_labels = df = pd.read_csv('training_set_clean_only_tags.txt', delimiter = "\t", header=None)

  # Add labels into training dataframe
  train_data['label'] = train_labels

  return train_data

  

def load_test():
  # Load test data (sentences)
  test_data = df = pd.read_csv('test_set_only_text.txt', delimiter = "\t", header=None)
  test_data.columns = ["text"]

  # Load test lables
  test_label = df = pd.read_csv('test_set_only_tags.txt', delimiter = "\t", header=None)

  # Add labels into test dataframe
  test_data['label'] = test_label

  return test_data

# Load the train and test data
train_data = load_training()
test_data = load_test()

# Visualise the distribution between the classes
import seaborn as sns
sns.countplot('label',data=train_data)

# Check for missing values
train_data.isnull().sum()

# Drop the duplicates
train_data.drop_duplicates(subset=['text'])

"""Data Cleaning
- stopwords
- polish letter replacement
- remote 'http'
- remove signs
- remove empty spaces
- remove numbers
- remove 'anonymizedaccount' word in each sentence
"""

def load_stop_words():
  with open('polish.stopwords.txt', encoding="utf-8", newline='\n') as f:
    stopwords = f.readlines()
  stopwords = [x[:-1] for x in stopwords]
  return stopwords

def replacePolishLetters(text):
    patterns = [ (r'ł', 'l'), 
                 (r'ó', 'o'),
                 (r'ą', 'a'),
                 (r'ć', 'c'),
                 (r'ę', 'e'),
                 (r'ń', 'n'),
                 (r'ś', 's'),
                 (r'ź', 'z'),
                 (r'ż', 'z')]
  
    for (pattern, repl) in patterns:
        text = re.sub(pattern, repl, text)
    return text

def removeStopwords(text):
    final_tokens = []
    tokens = text.split()
    stopwords_list = polish_stopwords
    
    for word in tokens:
        if (word not in stopwords_list):
            final_tokens.append(word)
            
    text = " ".join(final_tokens)
  
    return text

def clean_data(text):
    text = re.sub('\[.*?\]', '', text) # remove sings
    text = re.sub('https?://\S+|www\.\S+', '', text) # remove webiste addresses
    text = re.sub('<.*?>+', '', text) 
    text = re.sub('\n', '', text) # remove empyt spaces
    text = re.sub('\w*\d\w*', '', text) 
    text = re.sub('[^a-zA-Z ]', '', text)
    text = re.sub('[0-9]', '', text) # remove numbers
    text = re.sub('anonymizedaccount', '', text) # remove @anonymized_account tags
    text = str(text).lower()
    return text

# Apply the cleaning function to the dataframe
polish_stopwords = load_stop_words()
train_data['text']=train_data['text'].apply(removeStopwords) # remove stopwords
train_data['text']=train_data['text'].apply(replacePolishLetters) #replace polish letters

train_data['text']=train_data['text'].apply(clean_data) # clean the data
train_data.reset_index(drop=True, inplace=True) # reset the indexing from 0
preprocessed_train = train_data
preprocessed_train

"""Handle the lables for the training dataset:
- As the architecture will be predicting for three classes i.e. *non-harmful, cyberbullying and hate-speech* we need to prepare the lables are three dimentional tensor. 

**For instance:**
- non-harmful **(label 0)** : [1, 0, 0]
- cyberbullying **(label 1)** : [0, 1, 0]
- hate-speech **(label 2)** : [0, 0, 1]
"""

def non_harmful(label):
  if label == 0:
    return 1
  else:
    return 0

def cyberbullying(label):
  if label == 1:
    return 1
  
  else:
    return 0

def hate_speech(label):
  if label == 2:
    return 1
  else:
    return 0

preprocessed_train['non-harmful'] = preprocessed_train.apply(lambda x: non_harmful(x['label']),axis=1)
preprocessed_train['cyberbullying'] = preprocessed_train.apply(lambda x: cyberbullying(x['label']),axis=1)
preprocessed_train['hate_speech'] = preprocessed_train.apply(lambda x: hate_speech(x['label']),axis=1)
preprocessed_train

"""Train lables peraration"""

labels_ext = preprocessed_train[['non-harmful', 'cyberbullying', 'hate_speech']] # take only the classes
y_train = labels_ext.values # assign class values for the label training set

y_train.shape # check the shape

"""*Test* Data and lables preparation"""

test_data['text']=test_data['text'].apply(removeStopwords)
test_data['text']=test_data['text'].apply(replacePolishLetters)


test_data['text']=test_data['text'].apply(clean_data)
test_data.reset_index(drop=True, inplace=True)


test_data['non-harmful'] = test_data.apply(lambda x: non_harmful(x['label']),axis=1)
test_data['cyberbullying'] = test_data.apply(lambda x: cyberbullying(x['label']),axis=1)
test_data['hate_speech'] = test_data.apply(lambda x: hate_speech(x['label']),axis=1)


test_labels_ext = test_data[['non-harmful', 'cyberbullying', 'hate_speech']]

y_test = test_labels_ext.values

print(f'Test dataset has {len(test_data)} lenght and {test_data.shape} shape')
print(f'Test labels has {len(y_test)} lenght and {y_test.shape} shape')

X_train = preprocessed_train['text']
X_test = test_data['text']

# Split the data into training and valid set
#X_train, X_test, y_train, y_test = train_test_split(X_train, y_train, test_size=0.2, random_state=1)

from keras.preprocessing.text import Tokenizer

tokenizer = Tokenizer()
tokenizer.fit_on_texts(X_train)

word_index = tokenizer.word_index
vocab_size = len(tokenizer.word_index) + 1
print("Vocabulary Size :", vocab_size)

MAX_LENGTH = 30

from keras.preprocessing.sequence import pad_sequences

X_train = pad_sequences(tokenizer.texts_to_sequences(X_train), maxlen = MAX_LENGTH)
X_test = pad_sequences(tokenizer.texts_to_sequences(X_test),
                       maxlen = MAX_LENGTH)

print("Training X Shape:",X_train.shape)
print("Testing X Shape:",X_test.shape)

#GLOVE_EMB = 'glove.6B.300d.txt'
GLOVE_EMB = 'glove_100_3_polish.txt'
BATCH_SIZE = 256
EPOCHS = 15
MODEL_PATH = 'best_model.hdf5'

embeddings_index = {}

f = open(GLOVE_EMB)
for line in f:
    values = line.split()
    word = value = values[0]
    coefs = np.asarray(values[1:], dtype='float32')
    embeddings_index[word] = coefs
f.close()

print('Found %s word vectors.' %len(embeddings_index))

EMBEDDING_DIM = 100

embedding_matrix = np.zeros((vocab_size, EMBEDDING_DIM))
for word, i in word_index.items():
    embedding_vector = embeddings_index.get(word)
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector

embedding_layer = tf.keras.layers.Embedding(vocab_size, EMBEDDING_DIM, weights = [embedding_matrix], input_length = MAX_LENGTH, trainable = True)

sequence_input = Input(shape = (MAX_LENGTH,), dtype = 'int32')
embedding_sequences = embedding_layer(sequence_input)
x = SpatialDropout1D(0.5)(embedding_sequences)

#x = Conv1D(64, 5, activation = 'relu')(x)  # initially activation was relu
x = Conv1D(64, 5)(x) 
x = LeakyReLU(0.2)(x) # add LeakyRelu
x = Bidirectional(LSTM(64, dropout = 0.5, recurrent_dropout = 0.5))(x)
x = BatchNormalization(momentum=0.9)(x)
x = Dense(512, activation = 'tanh')(x) # initally activation was relu, changed to tanh just for explaration reason 
x = Dropout(0.5)(x)
x = Dense(512, activation = 'tanh')(x) # initally activation was relu, changed to tanh just for explaration reason 
x = Dropout(0.8)(x)
outputs = Dense(3, activation = 'softmax')(x) # softmax due to the multi-class use-case, 3 neuros on the output as we have 3 classes
model = tf.keras.Model(sequence_input, outputs)

model.summary()

learning_rate = 0.001

model.compile(optimizer = Adagrad(learning_rate = learning_rate), loss = 'categorical_crossentropy', metrics = ['accuracy'])
#ReduceLROnPlateau = ReduceLROnPlateau(factor = 0.1, min_lr = 0.01, monitor = 'val_loss', verbose = 1)

print("Training on GPU...") if tf.test.is_gpu_available() else print("Training on CPU...")

history = model.fit(X_train, y_train, batch_size = BATCH_SIZE, epochs = EPOCHS, validation_data = (X_test, y_test))

s, (at, al) = plt.subplots(2,1)
at.plot(history.history['accuracy'], c = 'b')
at.plot(history.history['val_accuracy'], c ='r')
at.set_title('model accuracy')
at.set_ylabel('accuracy')
at.set_xlabel('epoch')
at.legend(['LSTM_train', 'LSTM_val'], loc ='upper left')

al.plot(history.history['loss'], c ='m')
al.plot(history.history['val_loss'], c ='c')
al.set_title('model loss')
al.set_ylabel('loss')
al.set_xlabel('epoch')
al.legend(['train', 'val'], loc = 'upper left')

score = model.evaluate(X_test, y_test, verbose=1)
print("Test Score: ", score[0])
print("Test Accuracy: ", score[1])

# Save the model
model.save('/content/gdrive/MyDrive/Engineering/nlp-assignment/hawrot_model.h5')